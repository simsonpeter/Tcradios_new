<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, viewport-fit=cover"/>
<title>TC RADIOS</title>
<!-- PWA essentials -->
<link rel="manifest" href="/manifest.json">
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="TC RADIOS">
<link rel="apple-touch-icon" href="/icons/icon-192x192.png">
<link rel="icon" href="/icons/favicon.ico">
<!-- TWA/Android specific meta tags -->
<meta name="theme-color" content="#f97316">
<meta name="msapplication-navbutton-color" content="#f97316">
<meta name="msapplication-TileColor" content="#111827">
<meta name="application-name" content="TC RADIOS">
<!-- Font Awesome -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<style>
:root{
  --accent:#f97316;--bg:#111827;--card:#1f2937;--text:#f3f4f6;
  --border:#374151;--header:#000000;--heart:#f3f4f6;
  --header-btn:#f3f4f6;--player-height:80px;
}
[data-theme="light"]{
  --bg:#f5f7fa;--card:#ffffff;--text:#1e293b;
  --border:#d1d5db;--header:#ffffff;--heart:#1e293b;
  --header-btn:#1e293b;
}
*{box-sizing:border-box;margin:0;padding:0}
html,body{height:100%;height:100vh;height:100dvh;width:100%;overflow:hidden}
body{display:flex;flex-direction:column;font-family:system-ui;
     background:var(--bg);color:var(--text);overflow:hidden;
     /* Ensure fullscreen on mobile */
     position:fixed;top:0;left:0;right:0;bottom:0;
     /* Handle safe areas for notched devices */
     padding-top:env(safe-area-inset-top);
     padding-bottom:env(safe-area-inset-bottom);
     padding-left:env(safe-area-inset-left);
     padding-right:env(safe-area-inset-right)}
header{background:var(--header);border-bottom:1px solid var(--border);
       display:flex;justify-content:space-between;align-items:center;
       padding:1rem 1.2rem;font-size:1.25rem;font-weight:700;min-height:70px}
header button{background:none;border:none;font-size:1.4rem;cursor:pointer;padding:0.5rem;border-radius:50%;transition:all 0.2s ease;color:var(--header-btn)}
header button:hover{background:rgba(249,115,22,0.1);transform:scale(1.05)}
header button:active{transform:scale(0.95)}
header button i{font-size:1.2rem;color:var(--header-btn)}
#headerControls{display:flex;align-items:center;gap:0.8rem}
#langBox{position:relative}
#langSelect{appearance:none;background:var(--card);color:var(--text);
            border:1px solid var(--border);border-radius:.4rem;
            padding:.35rem .6rem;font-size:1rem;cursor:pointer}
#tabs{display:flex;border-bottom:1px solid var(--border);flex-shrink:0;
      background:var(--header)}
#tabs span{flex:1;text-align:center;padding:.55rem 0;cursor:pointer;
           font-weight:600;color:var(--text)}
#tabs span.active{background:var(--accent);color:#fff;border-radius:.4rem}
#content,#about-panel{flex:1;overflow-y:auto;padding:.75rem 1rem var(--player-height);
                      display:flex;flex-direction:column}
#about-panel{display:none;align-items:center;justify-content:center}
.about-card{background:var(--card);border-radius:.5rem;padding:1rem;
            text-align:center;box-shadow:0 1px 3px rgba(0,0,0,.08);
            width:90%;max-width:400px;margin-bottom:1rem}
.about-card img{width:90px;height:90px;border-radius:50%;object-fit:cover;margin-bottom:.5rem}
.about-card h2{margin:.3rem 0;font-size:1.2rem;color:var(--accent)}
.about-card p{font-size:.9rem;line-height:1.4}
.about-card i{margin-right:.5rem;color:var(--accent)}
#searchBar{width:100%;margin-bottom:.75rem;padding:.55rem .7rem;border-radius:.4rem;
           border:1px solid var(--border);background:var(--card);color:var(--text);
           font-size:1rem}
#searchBar::placeholder{color:var(--border)}
.station-list{width:100%;display:flex;flex-direction:column;gap:.4rem}
.item{display:flex;align-items:center;gap:12px;padding:.5rem;border-radius:.5rem;
      background:var(--card);box-shadow:0 1px 3px rgba(0,0,0,.08)}
.station-icon{width:48px;height:48px;border-radius:50%;object-fit:cover}
.station-info{flex:1;display:flex;flex-direction:column;text-align:left}
.station-name{font-weight:600}
.station-genre{font-size:.8rem;color:var(--accent)}
.favorite-button{font-size:1.3rem;color:var(--heart);cursor:pointer}
.favorite-button i{font-size:1.1rem}
.favorite-button.on{color:var(--accent)}
#player{background:var(--header);border-top:1px solid var(--border);
        display:flex;align-items:center;gap:1rem;padding:1rem 1.2rem;
        position:fixed;bottom:0;width:100%;flex-shrink:0;z-index:100;
        box-shadow:0 -2px 10px rgba(0,0,0,0.1);backdrop-filter:blur(10px)}
#player img{width:56px;height:56px;border-radius:50%;
           animation:spin 3s linear infinite paused;box-shadow:0 2px 8px rgba(0,0,0,0.2)}
#player.playing img{animation-play-state:running}
@keyframes spin{to{transform:rotate(360deg)}}
#player .info{flex:1;display:flex;flex-direction:column;justify-content:center;min-width:0;margin:0 1rem}
#player .name{white-space:nowrap;overflow:hidden;font-weight:700;font-size:1rem;margin-bottom:0.2rem}
#player .name span{display:inline-block;padding-right:1rem;
                   animation:marquee 8s linear infinite}
@keyframes marquee{0%{transform:translateX(100%)}100%{transform:translateX(-100%)}}
#player #p-now{font-size:.8rem;color:var(--accent);white-space:nowrap;font-weight:500}
#player .metadata{margin-top:0.3rem;font-size:0.75rem}
#player .song-title{color:var(--text);font-weight:500;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;margin-bottom:0.1rem}
#player .artist-name{color:var(--accent);font-weight:400;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;opacity:0.8}
#p-play,#p-prev,#p-next{background:rgba(249,115,22,0.1);border:none;color:var(--accent);
                        font-size:1.8rem;cursor:pointer;padding:0.8rem;border-radius:50%;
                        transition:all 0.2s ease;min-width:48px;min-height:48px;
                        display:flex;align-items:center;justify-content:center;
                        box-shadow:0 2px 4px rgba(0,0,0,0.1)}
#p-play:hover,#p-prev:hover,#p-next:hover{background:rgba(249,115,22,0.2);transform:scale(1.05)}
#p-play:active,#p-prev:active,#p-next:active{transform:scale(0.95)}
#p-play i,#p-prev i,#p-next i{font-size:1.3rem}
/* Mobile responsive adjustments */
/* Mobile Portrait */
@media (max-width: 480px) {
  #player{gap:0.8rem;padding:0.8rem 1rem}
  #player img{width:48px;height:48px}
  #player .info{margin:0 0.8rem}
  #player .name{font-size:0.9rem}
  #player #p-now{font-size:0.75rem}
  #player .metadata{font-size:0.7rem}
  #player .song-title{font-size:0.7rem}
  #player .artist-name{font-size:0.65rem}
  #p-play,#p-prev,#p-next{padding:0.6rem;min-width:44px;min-height:44px}
  #p-play i,#p-prev i,#p-next i{font-size:1.2rem}
  header{padding:0.8rem 1rem;min-height:60px}
  #headerControls{gap:0.6rem}
}
/* Mobile Landscape */
@media (max-width: 896px) and (orientation: landscape) {
  body{padding-bottom:60px}
  #player{
    flex-direction:row;
    padding:0.5rem 1rem;
    gap:1rem;
    min-height:60px;
  }
  #player img{width:40px;height:40px}
  #player .info{margin:0 0.5rem}
  #player .name{font-size:0.85rem;margin-bottom:0.1rem}
  #player #p-now{font-size:0.7rem}
  #player .metadata{font-size:0.65rem;margin-top:0.2rem}
  #player .song-title{font-size:0.65rem}
  #player .artist-name{font-size:0.6rem}
  #p-play,#p-prev,#p-next{padding:0.4rem;min-width:40px;min-height:40px}
  #p-play i,#p-prev i,#p-next i{font-size:1.1rem}
  header{padding:0.5rem 1rem;min-height:50px}
  .station-list .item{padding:0.6rem}
  .station-list .item img{width:32px;height:32px}
}
/* Touch-friendly enhancements */
@media (hover: none) and (pointer: coarse) {
  .station-list .item{padding:1rem;margin-bottom:0.5rem}
  .station-list .item:hover{transform:none}
  .station-list .item:active{transform:scale(0.98)}
  #p-play,#p-prev,#p-next{min-width:48px;min-height:48px}
  header button{min-width:44px;min-height:44px}
  .favorite-button{min-width:44px;min-height:44px}
}
/* Widget mode styles */
.widget-mode {
  padding: 0;
  background: transparent;
}
.widget-mode header,
.widget-mode .tabs,
.widget-mode .station-list {
  display: none;
}
.widget-mode #player {
  position: relative;
  border-radius: 12px;
  margin: 8px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
}
audio{display:none}
/* Android Wear / Smartwatch Styles */
@media (max-width: 400px) and (max-height: 400px) {
  body {
    font-size: 12px;
    padding: 4px;
  }
  header {
    padding: 0.3rem 0.5rem;
    min-height: 40px;
    font-size: 0.9rem;
  }
  #headerControls {
    gap: 0.3rem;
  }
  header button {
    min-width: 32px;
    min-height: 32px;
    font-size: 1rem;
    padding: 0.3rem;
  }
  #tabs {
    padding: 0.2rem;
  }
  #tabs span {
    padding: 0.3rem 0.2rem;
    font-size: 0.8rem;
  }
  .station-list .item {
    padding: 0.4rem;
    margin-bottom: 0.2rem;
  }
  .station-list .item img {
    width: 24px;
    height: 24px;
  }
  .station-name {
    font-size: 0.8rem;
  }
  .station-genre {
    font-size: 0.7rem;
  }
  #player {
    padding: 0.4rem 0.6rem;
    gap: 0.4rem;
    min-height: 50px;
  }
  #player img {
    width: 32px;
    height: 32px;
  }
  #player .info {
    margin: 0 0.3rem;
  }
  #player .name {
    font-size: 0.8rem;
    margin-bottom: 0.1rem;
  }
  #player #p-now {
    font-size: 0.6rem;
  }
  #player .metadata {
    font-size: 0.6rem;
    margin-top: 0.1rem;
  }
  #player .song-title {
    font-size: 0.6rem;
  }
  #player .artist-name {
    font-size: 0.55rem;
  }
  #p-play, #p-prev, #p-next {
    padding: 0.3rem;
    min-width: 32px;
    min-height: 32px;
    font-size: 1rem;
  }
  #p-play i, #p-prev i, #p-next i {
    font-size: 0.9rem;
  }
}
/* Round screen support for smartwatches */
@media (max-width: 400px) and (max-height: 400px) and (aspect-ratio: 1/1) {
  body {
    border-radius: 50%;
    overflow: hidden;
  }
  #content {
    border-radius: 50%;
    padding: 0.5rem;
  }
  .station-list .item {
    border-radius: 8px;
  }
  #player {
    border-radius: 20px;
  }
}
/* Ambient mode for smartwatches */
@media (prefers-reduced-motion: reduce) {
  #player img {
    animation: none;
  }
  .station-list .item:hover {
    transform: none;
  }
  .station-list .item:active {
    transform: scale(0.98);
  }
}
#sleepModal{position:fixed;inset:0;background:rgba(0,0,0,.5);
           display:none;align-items:center;justify-content:center;z-index:999}
#sleepModal>div{background:var(--card);padding:1rem;border-radius:.5rem;
                text-align:center;color:var(--text)}
#sleepModal button{margin:.3rem;padding:.4rem .8rem;border:1px solid var(--border);
                   border-radius:.3rem;background:var(--bg);color:var(--text)}
#sleepModal button:hover{background:var(--accent);color:#fff}

/* Drag and Drop Styles */
.item.dragging {
  opacity: 0.5;
  transform: rotate(5deg) scale(1.05);
  z-index: 1000;
  box-shadow: 0 8px 25px rgba(0,0,0,0.3);
}

.item.drag-over {
  border-top: 3px solid var(--accent);
  transform: translateY(-2px);
}

.item.drag-handle {
  cursor: grab;
  position: relative;
  user-select: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
}

.item.drag-handle:active {
  cursor: grabbing;
}

.item.drag-handle::before {
  content: "⋮⋮";
  position: absolute;
  left: 12px;
  top: 50%;
  transform: translateY(-50%);
  color: var(--border);
  font-size: 14px;
  line-height: 6px;
  opacity: 0.7;
  font-weight: bold;
  pointer-events: none;
}

.item.drag-handle:hover::before {
  opacity: 1;
  color: var(--accent);
}

.item.drag-handle:active::before {
  color: var(--accent);
  opacity: 1;
}

/* Touch-friendly drag handle */
@media (hover: none) and (pointer: coarse) {
  .item.drag-handle::before {
    opacity: 1;
    color: var(--accent);
    font-size: 16px;
  }
}

.favorites-reorder-hint {
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 12px;
  margin: 8px 0;
  text-align: center;
  color: var(--text);
  font-size: 14px;
  opacity: 0.8;
}

.favorites-reorder-hint i {
  color: var(--accent);
  margin-right: 8px;
}
</style>
</head>
<body>
<header>
  <span>TC RADIOS</span>
  <div id="headerControls">
  <div id="langBox">
    <select id="langSelect"></select>
    </div>
    <button id="sleepBtn" title="Sleep timer"><i class="fas fa-clock"></i></button>
    <button id="installBtn" title="Install App" style="display:none"><i class="fas fa-download"></i></button>
    <button id="themeToggle" title="Dark / Light"><i class="fas fa-moon"></i></button>
  </div>
</header>
<div id="tabs">
  <span id="tab-all" class="active">All</span>
  <span id="tab-fav">Favorites</span>
  <span id="tab-about">About</span>
</div>
<div id="content" aria-busy="true">
  <input id="searchBar" type="search" placeholder="Search stations…" autocomplete="off"/>
  <div class="station-list"></div>
</div>
<div id="about-panel">
  <div class="about-card">
    <img src="/icons/icon-512x512.png" alt="Logo"/>
    <h2>TC RADIOS</h2>
  </div>
  <div class="about-card">
    <h2>About Us</h2>
    <p>TC RADIOS brings uplifting Christian music and messages worldwide.</p>
  </div>
  <div class="about-card">
    <h2>Contact Us</h2>
    <p><strong>JayathaSoft</strong><br>
       <i class="fas fa-envelope"></i> <a href="mailto:simsonpeter@gmail.com">simsonpeter@gmail.com</a><br>
       <i class="fas fa-map-marker-alt"></i> Antwerp, Belgium</p>
  </div>
</div>
<div id="player">
  <img id="p-img" src="/icons/default-artwork.jpg" alt="Artwork"/>
  <div class="info">
    <div class="name"><span id="p-name"></span></div>
    <div id="p-now">Live</div>
    <div id="p-metadata" class="metadata" style="display:none;">
      <div id="p-song" class="song-title"></div>
      <div id="p-artist" class="artist-name"></div>
    </div>
  </div>
  <button id="p-prev" title="Previous"><i class="fas fa-step-backward"></i></button>
  <button id="p-play" title="Play/Pause"><i class="fas fa-play"></i></button>
  <button id="p-next" title="Next"><i class="fas fa-step-forward"></i></button>
</div>
<div id="sleepModal">
  <div>
    <h3>Sleep Timer</h3>
    <button data-min="15">15 min</button><button data-min="30">30 min</button>
    <button data-min="45">45 min</button><button data-min="60">60 min</button><br>
    <input type="number" id="customMin" placeholder="min" style="width:70px"/>
    <button id="setCustom">Set</button><br>
    <button id="cancelSleep">Cancel</button>
  </div>
</div>
<audio id="audio"></audio>
<script>
/* ---- CONFIG ---- */
const LANG_URLS = {
  tamil:    'https://raw.githubusercontent.com/simsonpeter/Tcradios/refs/heads/main/stations.json',
  english:  'https://raw.githubusercontent.com/simsonpeter/Tcradios/refs/heads/main/languages/english.json',
  dutch:    'https://raw.githubusercontent.com/simsonpeter/Tcradios/refs/heads/main/languages/dutch.json',
  hindi:    'https://raw.githubusercontent.com/simsonpeter/Tcradios/refs/heads/main/languages/hindi.json',
  malayalam:'https://raw.githubusercontent.com/simsonpeter/Tcradios/refs/heads/main/languages/malayalam.json'
  // --- FUTURE LANGUAGES GO HERE ---
  // spanish: 'https://yourdomain.com/path/to/spanish.json',
  // french: 'https://yourdomain.com/path/to/french.json'
};
/* ---- STATE ---- */
let stationsPerLang = {};
let favorites       = JSON.parse(localStorage.getItem('tcr-fav') || '[]');
let favoritesOrder  = JSON.parse(localStorage.getItem('tcr-fav-order') || '[]'); // Custom order for favorites
let currentLang     = localStorage.getItem('currentLang') || 'english';
let currentTab      = localStorage.getItem('currentTab') || 'all';
let currentList     = [];
let idx             = 0;
let searchTerm      = '';
let sleepTimer;
let lastPlayedStation = JSON.parse(localStorage.getItem('tcr-last-played') || 'null');
/* ---- ELEMENTS ---- */
const searchBar   = document.getElementById('searchBar');
const stationList = document.querySelector('.station-list');
const audio       = document.getElementById('audio');
const pImg        = document.getElementById('p-img');
const pName       = document.getElementById('p-name');
const pPlay       = document.getElementById('p-play');
const player      = document.getElementById('player');
/* ---- LOAD + INIT ---- */
async function loadAll() {
  const promises = Object.keys(LANG_URLS).map(async lang => {
    try {
      console.log(`Loading ${lang} stations from:`, LANG_URLS[lang]);
      const res = await fetch(LANG_URLS[lang]);
      if (!res.ok) {
        throw new Error(`Failed to load ${lang} stations: ${res.status}`);
      }
      stationsPerLang[lang] = await res.json();
      console.log(`${lang} stations loaded:`, stationsPerLang[lang].length, 'stations');
    } catch (error) {
      console.error(`Error loading ${lang} stations:`, error);
      stationsPerLang[lang] = []; // Set empty array on error
    }
  });
  await Promise.allSettled(promises);
  console.log('All stations loaded:', stationsPerLang);
  // Data is now loaded. The calling function will handle UI updates.
}
// Make the main initialization async
(async function initApp() {
  await loadAll(); // <-- AWAIT the loading to finish
  // Now that data is loaded, populate UI
  populateLangSelect();
  // Handle URL parameters for shortcuts
  const urlParams = new URLSearchParams(window.location.search);
  const action = urlParams.get('action');
  const tab = urlParams.get('tab');
  if (tab) {
    currentTab = tab;
    localStorage.setItem('currentTab', currentTab);
  }
  switchTab(currentTab);
  // Auto-play last played station or first station
  setTimeout(() => {
    if (action === 'resume') {
      // Force resume last played station
      if (lastPlayedStation && lastPlayedStation.lang === currentLang) {
        const stations = stationsPerLang[currentLang] || [];
        const lastStation = stations.find(st => st.name === lastPlayedStation.station.name);
        if (lastStation) {
          const index = stations.indexOf(lastStation);
          play(lastStation, index);
          return;
        }
      }
    } else if (action === 'quickplay') {
      // Quick play first station
      const stations = stationsPerLang[currentLang] || [];
      if (stations.length > 0) {
        play(stations[0], 0);
        return;
      }
    }
    autoPlayLastOrFirst();
  }, 500); // Small delay to ensure UI is ready
})();
function autoPlayLastOrFirst() {
  // Check if there's a last played station
  if (lastPlayedStation && lastPlayedStation.lang === currentLang) {
    const stations = stationsPerLang[currentLang] || [];
    const lastStation = stations.find(st => st.name === lastPlayedStation.station.name);
    if (lastStation) {
      const index = stations.indexOf(lastStation);
      play(lastStation, index);
      return;
    }
  }
  // If no last played station or it's not found, play first station
  const stations = stationsPerLang[currentLang] || [];
  if (stations.length > 0) {
    play(stations[0], 0);
  }
}
function populateLangSelect() {
  const sel = document.getElementById('langSelect');
  sel.innerHTML = '';
  Object.keys(LANG_URLS).forEach(lang => {
    const opt = document.createElement('option');
    opt.value = lang;
    opt.textContent = lang.charAt(0).toUpperCase() + lang.slice(1);
    if (lang === currentLang) opt.selected = true;
    sel.appendChild(opt);
  });
  sel.onchange = () => {
    currentLang = sel.value;
    console.log('Language changed to:', currentLang);
    console.log('Available stations for', currentLang, ':', stationsPerLang[currentLang]);
    localStorage.setItem('currentLang', currentLang);
    switchTab(currentTab);
    // Auto-play last played station or first station when language changes
    setTimeout(() => {
      autoPlayLastOrFirst();
    }, 100);
  };
}
/* ---- TABS + SEARCH ---- */
document.getElementById('tab-all').onclick   = () => switchTab('all');
document.getElementById('tab-fav').onclick   = () => switchTab('fav');
document.getElementById('tab-about').onclick = () => switchTab('about');
document.getElementById('content').addEventListener('touchstart', e => touchStartX = e.changedTouches[0].screenX);
document.getElementById('content').addEventListener('touchend', e => {
  const th = 50;
  if (e.changedTouches[0].screenX < touchStartX - th) {
    const i = ['all','fav','about'].indexOf(currentTab);
    if (i < 2) switchTab(['all','fav','about'][i+1]);
  } else if (touchStartX < e.changedTouches[0].screenX - th) {
    const i = ['all','fav','about'].indexOf(currentTab);
    if (i > 0) switchTab(['all','fav','about'][i-1]);
  }
});
searchBar.addEventListener('input', e => {
  searchTerm = e.target.value.trim().toLowerCase();
  switchTab(currentTab);
});
function switchTab(tab) {
  currentTab = tab;
  localStorage.setItem('currentTab', tab);
  document.querySelectorAll('#tabs span').forEach(s => s.classList.remove('active'));
  document.getElementById(`tab-${tab}`).classList.add('active');
  if (tab === 'about') {
    document.getElementById('content').style.display = 'none';
    document.getElementById('about-panel').style.display = 'flex';
    searchBar.style.display = 'none';
  } else {
    document.getElementById('content').style.display = 'flex';
    document.getElementById('about-panel').style.display = 'none';
    searchBar.style.display = '';
    let base = tab === 'fav'
      ? getFavoritesInOrder()
      : stationsPerLang[currentLang] || [];
    currentList = base.filter(s => !searchTerm || s.name.toLowerCase().includes(searchTerm));
    render(currentList);
  }
}
/* ---- RENDER ---- */
function render(list) {
  stationList.innerHTML = '';
  
  // Add reorder hint for favorites tab
  if (currentTab === 'fav' && list.length > 1) {
    const hint = document.createElement('div');
    hint.className = 'favorites-reorder-hint';
    hint.innerHTML = '<i class="fas fa-grip-vertical"></i>Hold and drag to reorder your favorites';
    stationList.appendChild(hint);
  }
  
  if (!list || !list.length) {
    stationList.innerHTML = '<div class="item">No stations found.</div>';
    return;
  }
  
  list.forEach((st, i) => {
    const div = document.createElement('div');
    div.className = 'item';
    
    // Add drag handle class for favorites tab
    if (currentTab === 'fav') {
      div.className += ' drag-handle';
      div.draggable = true;
      div.dataset.index = i;
      
      // Drag and drop event listeners
      div.addEventListener('dragstart', handleDragStart);
      div.addEventListener('dragover', handleDragOver);
      div.addEventListener('drop', handleDrop);
      div.addEventListener('dragend', handleDragEnd);
      
      // Touch event listeners for mobile
      div.addEventListener('touchstart', handleTouchStart, { passive: false });
      div.addEventListener('touchmove', handleTouchMove, { passive: false });
      div.addEventListener('touchend', handleTouchEnd, { passive: false });
    }
    
    div.innerHTML = `
      <img src="${st.logo}" alt="" class="station-icon">
      <div class="station-info">
        <div class="station-name">${st.name}</div>
        <div class="station-genre">${st.genre}</div>
      </div>
      <div class="favorite-button ${favorites.includes(st.name) ? 'on' : ''}" data-name="${st.name}"><i class="fas fa-heart"></i></div>
    `;
    
    div.onclick = e => { if (!e.target.classList.contains('favorite-button')) play(st, i); };
    div.querySelector('.favorite-button').onclick = e => {
      e.stopPropagation(); toggleFav(st.name);
    };
    stationList.appendChild(div);
  });
}
/* ---- PLAYER ---- */
function play(st, i) {
  idx = i;
  audio.src = st.url;
  pImg.src = st.logo || '/icons/default-artwork.jpg';
  pName.innerHTML = '<span>' + st.name + '</span>';
  player.classList.add('playing');
  audio.play().catch(()=>{});
  updateMediaSession(st);
  // Update Wear OS media session
  updateWearOSMediaSession(st);
  // Start metadata fetching (will show only if metadata is available)
  startMetadataFetching(st);
  // Save last played station
  lastPlayedStation = { station: st, index: i, lang: currentLang };
  localStorage.setItem('tcr-last-played', JSON.stringify(lastPlayedStation));
  // Haptic feedback for mobile
  hapticFeedback('success');
  // Request notification permission on first play
  requestNotificationPermission();
}
audio.onplay  = () => { 
  pPlay.innerHTML = '<i class="fas fa-pause"></i>'; 
  player.classList.add('playing'); 
  hapticFeedback('light');
  updateWidget('playStateUpdate', { playing: true });
};
audio.onpause = () => { 
  pPlay.innerHTML = '<i class="fas fa-play"></i>'; 
  player.classList.remove('playing'); 
  hapticFeedback('light');
  updateWidget('playStateUpdate', { playing: false });
  // Stop metadata fetching when paused
  stopMetadataFetching();
};
pPlay.onclick = () => {
  hapticFeedback('medium');
  audio.paused ? audio.play() : audio.pause();
};
function prevNext(dir) {
  if (!currentList.length) return;
  idx = (idx + dir + currentList.length) % currentList.length;
  play(currentList[idx], idx);
  hapticFeedback('light');
}
document.getElementById('p-prev').onclick = () => prevNext(-1);
document.getElementById('p-next').onclick = () => prevNext(1);
/* ---- METADATA FUNCTIONS ---- */
let metadataInterval;
let currentMetadata = { song: '', artist: '' };
let metadataAttempts = 0;
const MAX_METADATA_ATTEMPTS = 3;
function updateMetadata(song, artist) {
  const songElement = document.getElementById('p-song');
  const artistElement = document.getElementById('p-artist');
  const metadataContainer = document.getElementById('p-metadata');
  // Only show metadata if we have actual content
  if (song && song.trim() && song !== 'Loading metadata...' && song !== 'Metadata not available' && song !== 'Refreshing...') {
    if (songElement) songElement.textContent = song;
    if (artistElement) artistElement.textContent = artist || '';
    if (metadataContainer) metadataContainer.style.display = 'block';
    currentMetadata = { song, artist };
    // Update widget with metadata
    updateWidget('metadataUpdate', { song, artist });
    // Debug logging
    console.log('Metadata updated:', { song, artist });
  } else {
    // Hide metadata container if no valid metadata
    if (metadataContainer) metadataContainer.style.display = 'none';
  }
}
function startMetadataFetching(station) {
  // Clear existing interval
  if (metadataInterval) {
    clearInterval(metadataInterval);
  }
  // Reset attempts counter
  metadataAttempts = 0;
  // Hide metadata initially
  const metadataContainer = document.getElementById('p-metadata');
  if (metadataContainer) metadataContainer.style.display = 'none';
  // Try to fetch metadata from various sources
  fetchMetadataFromStream(station);
  // Set up periodic metadata updates
  metadataInterval = setInterval(() => {
    metadataAttempts++;
    if (metadataAttempts >= MAX_METADATA_ATTEMPTS) {
      // Stop trying after max attempts - don't show any message
      stopMetadataFetching();
      return;
    }
    fetchMetadataFromStream(station);
  }, 15000); // Update every 15 seconds
}
function fetchMetadataFromStream(station) {
  console.log('Fetching metadata for:', station.name);
  // Try multiple metadata sources
  const metadataSources = [
    // Icecast metadata endpoint
    station.url.replace(/\/stream.*$/, '/status-json.xsl'),
    // Shoutcast metadata endpoint  
    station.url.replace(/\/stream.*$/, '/stats?json=1'),
    // Generic metadata endpoint
    station.url.replace(/\/stream.*$/, '/metadata'),
    // Alternative Icecast endpoint
    station.url.replace(/\/stream.*$/, '/status.xsl'),
    // Alternative endpoints
    station.url.replace(/\/stream.*$/, '/7.html'),
    station.url.replace(/\/stream.*$/, '/currentsong'),
    station.url.replace(/\/stream.*$/, '/nowplaying'),
    // Direct stream metadata (if supported)
    station.url
  ];
  // Add station-specific metadata sources
  if (station.name.toLowerCase().includes('shalom')) {
    metadataSources.push(
      station.url.replace(/\/stream.*$/, '/shoutcast'),
      station.url.replace(/\/stream.*$/, '/info'),
      station.url.replace(/\/stream.*$/, '/title')
    );
  }
  if (station.name.toLowerCase().includes('sweety')) {
    metadataSources.push(
      station.url.replace(/\/stream.*$/, '/sweety'),
      station.url.replace(/\/stream.*$/, '/current'),
      station.url.replace(/\/stream.*$/, '/playing')
    );
  }
  // Try each source
  metadataSources.forEach((source, index) => {
    setTimeout(() => {
      fetchMetadataFromSource(source, station, index);
    }, index * 1000); // Stagger requests
  });
  // Also try to extract metadata from audio element if available
  extractMetadataFromAudio();
  // Try to get metadata from stream headers
  fetchStreamHeaders(station);
}
function fetchMetadataFromSource(url, station, sourceIndex) {
  console.log(`Trying metadata source ${sourceIndex + 1}:`, url);
  fetch(url, { 
    method: 'GET',
    mode: 'cors',
    headers: {
      'Accept': 'application/json, text/plain, */*'
    },
    timeout: 5000
  })
  .then(response => {
    if (response.ok) {
      return response.json();
    }
    throw new Error(`HTTP ${response.status}`);
  })
  .then(data => {
    console.log('Metadata response:', data);
    parseMetadataResponse(data, station);
  })
  .catch(error => {
    console.log(`Metadata fetch failed for source ${sourceIndex + 1}:`, error.message);
  });
}
function parseMetadataResponse(data, station) {
  let song = '';
  let artist = '';
  // Parse different metadata formats
  if (data.icestats && data.icestats.source) {
    // Icecast format
    const source = data.icestats.source;
    if (source.title) {
      const parts = source.title.split(' - ');
      artist = parts[0] || '';
      song = parts[1] || source.title;
    }
  } else if (data.songtitle) {
    // Shoutcast format
    song = data.songtitle;
    artist = data.artist || '';
  } else if (data.title) {
    // Generic format
    const parts = data.title.split(' - ');
    artist = parts[0] || '';
    song = parts[1] || data.title;
  } else if (data.currentsong) {
    // Alternative format
    song = data.currentsong;
    artist = data.artist || '';
  } else if (data.now_playing) {
    // Another alternative format
    song = data.now_playing;
    artist = data.artist || '';
  }
  // Update display if we got valid metadata
  if (song && song !== currentMetadata.song) {
    updateMetadata(song, artist);
    console.log('Successfully parsed metadata:', { song, artist });
  }
}
function extractMetadataFromAudio() {
  // Try to get metadata from audio element if browser supports it
  if (audio.mozGetMetadata) {
    try {
      const metadata = audio.mozGetMetadata();
      if (metadata && metadata.title) {
        const parts = metadata.title.split(' - ');
        const artist = parts[0] || '';
        const song = parts[1] || metadata.title;
        updateMetadata(song, artist);
        console.log('Extracted metadata from audio:', { song, artist });
      }
    } catch (e) {
      console.log('Audio metadata extraction failed:', e);
    }
  }
  // Try to get metadata from audio events
  audio.addEventListener('loadedmetadata', () => {
    if (audio.mozGetMetadata) {
      try {
        const metadata = audio.mozGetMetadata();
        if (metadata && metadata.title) {
          const parts = metadata.title.split(' - ');
          const artist = parts[0] || '';
          const song = parts[1] || metadata.title;
          updateMetadata(song, artist);
          console.log('Audio metadata loaded:', { song, artist });
        }
      } catch (e) {
        console.log('Audio metadata load failed:', e);
      }
    }
  });
}
function fetchStreamHeaders(station) {
  // Try to get metadata from stream headers
  fetch(station.url, {
    method: 'HEAD',
    mode: 'cors'
  })
  .then(response => {
    const icyName = response.headers.get('icy-name');
    const icyDescription = response.headers.get('icy-description');
    const icyGenre = response.headers.get('icy-genre');
    const icyTitle = response.headers.get('icy-title');
    if (icyTitle) {
      const parts = icyTitle.split(' - ');
      const artist = parts[0] || '';
      const song = parts[1] || icyTitle;
      updateMetadata(song, artist);
      console.log('Stream header metadata:', { song, artist });
    } else if (icyName) {
      updateMetadata(icyName, icyDescription || '');
      console.log('Stream name metadata:', icyName);
    }
  })
  .catch(error => {
    console.log('Stream header fetch failed:', error.message);
  });
}
function stopMetadataFetching() {
  if (metadataInterval) {
    clearInterval(metadataInterval);
    metadataInterval = null;
  }
  console.log('Metadata fetching stopped');
}
/* ---- FAVORITES ---- */
function toggleFav(name) {
  const wasFavorite = favorites.includes(name);
  
  if (wasFavorite) {
    // Remove from favorites
    favorites = favorites.filter(f => f !== name);
    favoritesOrder = favoritesOrder.filter(f => f !== name);
  } else {
    // Add to favorites
    favorites = [...favorites, name];
    favoritesOrder = [...favoritesOrder, name];
  }
  
  localStorage.setItem('tcr-fav', JSON.stringify(favorites));
  localStorage.setItem('tcr-fav-order', JSON.stringify(favoritesOrder));
  switchTab(currentTab);
  // Haptic feedback for favorite toggle
  hapticFeedback(favorites.includes(name) ? 'success' : 'light');
}

function getFavoritesInOrder() {
  const allStations = Object.values(stationsPerLang).flat();
  const favoriteStations = [];
  
  // First, add stations in custom order
  favoritesOrder.forEach(stationName => {
    const station = allStations.find(s => s.name === stationName);
    if (station && favorites.includes(stationName)) {
      favoriteStations.push(station);
    }
  });
  
  // Then add any new favorites that aren't in the order yet
  favorites.forEach(stationName => {
    if (!favoritesOrder.includes(stationName)) {
      const station = allStations.find(s => s.name === stationName);
      if (station) {
        favoriteStations.push(station);
        favoritesOrder.push(stationName);
      }
    }
  });
  
  // Save updated order
  localStorage.setItem('tcr-fav-order', JSON.stringify(favoritesOrder));
  
  return favoriteStations;
}

function reorderFavorites(fromIndex, toIndex) {
  if (fromIndex === toIndex) return;
  
  // Move item in favoritesOrder array
  const item = favoritesOrder.splice(fromIndex, 1)[0];
  favoritesOrder.splice(toIndex, 0, item);
  
  // Save new order
  localStorage.setItem('tcr-fav-order', JSON.stringify(favoritesOrder));
  
  // Re-render favorites tab if currently active
  if (currentTab === 'fav') {
    switchTab('fav');
  }
  
  // Haptic feedback
  hapticFeedback('success');
}

// Drag and Drop Variables
let draggedElement = null;
let draggedIndex = null;
let touchStartY = 0;
let touchStartElement = null;
let isDragging = false;

// Drag and Drop Event Handlers
function handleDragStart(e) {
  console.log('Drag start:', e.target);
  draggedElement = e.target;
  draggedIndex = parseInt(e.target.dataset.index);
  e.target.classList.add('dragging');
  e.dataTransfer.effectAllowed = 'move';
  e.dataTransfer.setData('text/plain', draggedIndex.toString());
  
  // Prevent default to allow custom drag behavior
  e.stopPropagation();
}

function handleDragOver(e) {
  e.preventDefault();
  e.dataTransfer.dropEffect = 'move';
  
  // Add visual feedback
  const afterElement = getDragAfterElement(stationList, e.clientY);
  const dragging = document.querySelector('.dragging');
  
  if (dragging) {
    if (afterElement == null) {
      stationList.appendChild(dragging);
    } else {
      stationList.insertBefore(dragging, afterElement);
    }
  }
}

function handleDrop(e) {
  e.preventDefault();
  e.stopPropagation();
  
  console.log('Drop event:', e.target);
  
  if (draggedElement && currentTab === 'fav') {
    const dropIndex = Array.from(stationList.querySelectorAll('.item')).indexOf(e.target);
    
    console.log('Drop index:', dropIndex, 'Dragged index:', draggedIndex);
    
    // Only reorder if it's a valid drop and indices are different
    if (dropIndex >= 0 && dropIndex !== draggedIndex) {
      reorderFavorites(draggedIndex, dropIndex);
    }
  }
}

function handleDragEnd(e) {
  console.log('Drag end');
  e.target.classList.remove('dragging');
  draggedElement = null;
  draggedIndex = null;
  
  // Remove drag-over class from all items
  document.querySelectorAll('.item').forEach(item => {
    item.classList.remove('drag-over');
  });
}

function getDragAfterElement(container, y) {
  const draggableElements = [...container.querySelectorAll('.item:not(.dragging)')];
  
  return draggableElements.reduce((closest, child) => {
    const box = child.getBoundingClientRect();
    const offset = y - box.top - box.height / 2;
    
    if (offset < 0 && offset > closest.offset) {
      return { offset: offset, element: child };
    } else {
      return closest;
    }
  }, { offset: Number.NEGATIVE_INFINITY }).element;
}

// Touch Event Handlers for Mobile
function handleTouchStart(e) {
  if (currentTab !== 'fav') return;
  
  touchStartElement = e.target.closest('.item');
  touchStartY = e.touches[0].clientY;
  draggedIndex = parseInt(touchStartElement.dataset.index);
  
  console.log('Touch start:', touchStartElement);
  
  // Add visual feedback
  touchStartElement.classList.add('dragging');
  isDragging = false;
}

function handleTouchMove(e) {
  if (!touchStartElement || currentTab !== 'fav') return;
  
  const touchY = e.touches[0].clientY;
  const deltaY = touchY - touchStartY;
  
  // Start dragging if moved more than 10px
  if (Math.abs(deltaY) > 10 && !isDragging) {
    isDragging = true;
    e.preventDefault();
    console.log('Started dragging');
  }
  
  if (isDragging) {
    e.preventDefault();
    
    // Move the element visually
    const afterElement = getDragAfterElement(stationList, touchY);
    if (afterElement == null) {
      stationList.appendChild(touchStartElement);
    } else {
      stationList.insertBefore(touchStartElement, afterElement);
    }
  }
}

function handleTouchEnd(e) {
  if (!touchStartElement || currentTab !== 'fav') return;
  
  if (isDragging) {
    const dropIndex = Array.from(stationList.querySelectorAll('.item')).indexOf(touchStartElement);
    
    console.log('Touch drop index:', dropIndex, 'Dragged index:', draggedIndex);
    
    if (dropIndex >= 0 && dropIndex !== draggedIndex) {
      reorderFavorites(draggedIndex, dropIndex);
    }
  }
  
  // Clean up
  touchStartElement.classList.remove('dragging');
  touchStartElement = null;
  draggedIndex = null;
  isDragging = false;
}

/* ---- THEME ---- */
const themeToggle = document.getElementById('themeToggle');
function applyTheme(t) {
  document.documentElement.setAttribute('data-theme', t);
  localStorage.theme = t;
  themeToggle.innerHTML = t === 'dark' ? '<i class="fas fa-sun"></i>' : '<i class="fas fa-moon"></i>';
}
applyTheme(localStorage.theme || (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light'));
themeToggle.onclick = () => applyTheme(document.documentElement.getAttribute('data-theme') === 'dark' ? 'light' : 'dark');
/* ---- SLEEP TIMER ---- */
const sleepModal = document.getElementById('sleepModal');
const sleepBtn   = document.getElementById('sleepBtn');
sleepBtn.onclick = () => sleepModal.style.display = 'flex';
document.getElementById('cancelSleep').onclick = () => {
  clearTimeout(sleepTimer);
  sleepModal.style.display = 'none';
};
document.querySelectorAll('#sleepModal button[data-min]').forEach(btn => {
  btn.onclick = () => setSleep(parseInt(btn.dataset.min));
});
document.getElementById('setCustom').onclick = () => {
  const m = parseInt(document.getElementById('customMin').value);
  if (m > 0) setSleep(m);
};
function setSleep(min) {
  clearTimeout(sleepTimer);
  sleepTimer = setTimeout(() => {
    audio.pause();
    document.getElementById('p-now').textContent = 'Live';
    sleepModal.style.display = 'none';
  }, min * 60000);
  sleepModal.style.display = 'none';
}
/* ---- MEDIA SESSION ---- */
function updateMediaSession(st) {
  if ('mediaSession' in navigator) {
    navigator.mediaSession.metadata = new MediaMetadata({
      title: st.name,
      artist: 'TC RADIOS',
      album: st.genre,
      artwork: [{
        src: st.logo || '/icons/icon-512x512.png',
        sizes: '512x512', type: 'image/png'
      }]
    });
    // Enhanced media session controls for Android Auto
    navigator.mediaSession.setActionHandler('play', () => {
      audio.play();
      showNotification('Playing: ' + st.name);
      updateWidget('playStateUpdate', { playing: true });
    });
    navigator.mediaSession.setActionHandler('pause', () => {
      audio.pause();
      showNotification('Paused: ' + st.name);
      updateWidget('playStateUpdate', { playing: false });
    });
    navigator.mediaSession.setActionHandler('previoustrack', () => {
      prevNext(-1);
      showNotification('Previous station');
    });
    navigator.mediaSession.setActionHandler('nexttrack', () => {
      prevNext(1);
      showNotification('Next station');
    });
    // Add stop action for better mobile support
    navigator.mediaSession.setActionHandler('stop', () => {
      audio.pause();
      audio.currentTime = 0;
      showNotification('Stopped');
      updateWidget('playStateUpdate', { playing: false });
    });
    // Android Auto specific handlers
    navigator.mediaSession.setActionHandler('seekbackward', (details) => {
      // Skip backward 10 seconds (if supported by stream)
      showNotification('Seek backward');
    });
    navigator.mediaSession.setActionHandler('seekforward', (details) => {
      // Skip forward 10 seconds (if supported by stream)
      showNotification('Seek forward');
    });
    // Update widget with station info
    updateWidget('stationUpdate', { station: st });
  }
}
/* ---- WIDGET COMMUNICATION ---- */
function updateWidget(type, data) {
  // Send message to widget iframe
  const widgetFrame = document.querySelector('iframe[src*="widget-template"]');
  if (widgetFrame) {
    widgetFrame.contentWindow.postMessage({ type: type, ...data }, '*');
  }
  // Also send to any open widget windows
  if (window.widgetWindow && !window.widgetWindow.closed) {
    window.widgetWindow.postMessage({ type: type, ...data }, '*');
  }
}
// Listen for messages from widget
window.addEventListener('message', (event) => {
  if (event.data.action) {
    switch(event.data.action) {
      case 'play':
        audio.paused ? audio.play() : audio.pause();
        break;
      case 'prev':
        prevNext(-1);
        break;
      case 'next':
        prevNext(1);
        break;
      case 'theme':
        toggleTheme();
        break;
      case 'timer':
        document.getElementById('sleepBtn').click();
        break;
    }
  }
});
/* ---- ANDROID AUTO SUPPORT ---- */
function initAndroidAuto() {
  // Enhanced media session for Android Auto
  if ('mediaSession' in navigator) {
    // Set playback state
    navigator.mediaSession.playbackState = 'none';
    // Add position state for Android Auto
    navigator.mediaSession.setPositionState({
      duration: Infinity, // Radio streams are continuous
      playbackRate: 1.0,
      position: 0
    });
    // Handle Android Auto specific events
    navigator.mediaSession.setActionHandler('seekto', (details) => {
      if (details.seekTime !== undefined) {
        audio.currentTime = details.seekTime;
        showNotification('Seek to ' + Math.round(details.seekTime) + 's');
      }
    });
  }
  // Register for Android Auto
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.addEventListener('message', (event) => {
      if (event.data.type === 'ANDROID_AUTO_COMMAND') {
        handleAndroidAutoCommand(event.data.command);
      }
    });
  }
}
function handleAndroidAutoCommand(command) {
  switch(command.action) {
    case 'PLAY':
      audio.play();
      break;
    case 'PAUSE':
      audio.pause();
      break;
    case 'NEXT':
      prevNext(1);
      break;
    case 'PREVIOUS':
      prevNext(-1);
      break;
    case 'STOP':
      audio.pause();
      audio.currentTime = 0;
      break;
  }
}
/* ---- MOBILE NOTIFICATIONS ---- */
/* ---- ENHANCED NOTIFICATIONS ---- */
function showNotification(message, actions = []) {
  if ('Notification' in window && Notification.permission === 'granted') {
    const notification = new Notification('TC RADIOS', {
      body: message,
      icon: '/icons/icon-192x192.png',
      badge: '/icons/icon-192x192.png',
      tag: 'tcradios-control',
      actions: actions,
      requireInteraction: true,
      silent: false
    });
    // Handle notification click
    notification.onclick = () => {
      window.focus();
      notification.close();
    };
    // Auto-close after 5 seconds unless it has actions
    if (actions.length === 0) {
      setTimeout(() => notification.close(), 5000);
    }
  }
}
function showMediaNotification(station) {
  if ('Notification' in window && Notification.permission === 'granted') {
    const actions = [
      { action: 'play', title: 'Play', icon: '/icons/icon-192x192.png' },
      { action: 'pause', title: 'Pause', icon: '/icons/icon-192x192.png' },
      { action: 'next', title: 'Next', icon: '/icons/icon-192x192.png' },
      { action: 'prev', title: 'Previous', icon: '/icons/icon-192x192.png' }
    ];
    showNotification(`Now Playing: ${station.name}`, actions);
  }
}
// Request notification permission on first interaction
function requestNotificationPermission() {
  if ('Notification' in window && Notification.permission === 'default') {
    Notification.requestPermission();
  }
}
/* ---- SWIPE GESTURES ---- */
let touchStartX = 0;
let touchStartY = 0;
let touchEndX = 0;
let touchEndY = 0;
document.addEventListener('touchstart', e => {
  touchStartX = e.changedTouches[0].screenX;
  touchStartY = e.changedTouches[0].screenY;
}, false);
document.addEventListener('touchend', e => {
  touchEndX = e.changedTouches[0].screenX;
  touchEndY = e.changedTouches[0].screenY;
  handleSwipe();
}, false);
function handleSwipe() {
  const deltaX = touchEndX - touchStartX;
  const deltaY = touchEndY - touchStartY;
  const minSwipeDistance = 50;
  // Only handle horizontal swipes
  if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > minSwipeDistance) {
    if (deltaX > 0) {
      // Swipe right - previous station
      prevNext(-1);
      showNotification('Previous station');
    } else {
      // Swipe left - next station
      prevNext(1);
      showNotification('Next station');
    }
  }
}
/* ---- HAPTIC FEEDBACK ---- */
function hapticFeedback(type = 'light') {
  if ('vibrate' in navigator) {
    switch(type) {
      case 'light': navigator.vibrate(10); break;
      case 'medium': navigator.vibrate(50); break;
      case 'heavy': navigator.vibrate([100, 50, 100]); break;
      case 'success': navigator.vibrate([50, 50, 50]); break;
      case 'error': navigator.vibrate([200, 100, 200]); break;
    }
  }
}
/* ---- SERVICE WORKER (PWA) ---- */
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('/sw.js');
  });
}
/* ---- PWA INSTALLATION ---- */
let deferredPrompt;
window.addEventListener('beforeinstallprompt', (e) => {
  // Prevent the mini-infobar from appearing on mobile
  e.preventDefault();
  // Stash the event so it can be triggered later
  deferredPrompt = e;
  // Show install button
  const installBtn = document.getElementById('installBtn');
  if (installBtn) {
    installBtn.style.display = 'block';
  }
});
// Handle install button click
document.getElementById('installBtn').addEventListener('click', async () => {
  if (deferredPrompt) {
    // Show the install prompt
    deferredPrompt.prompt();
    // Wait for the user to respond to the prompt
    const { outcome } = await deferredPrompt.userChoice;
    console.log(`User response to the install prompt: ${outcome}`);
    // Clear the deferredPrompt variable
    deferredPrompt = null;
    // Hide install button
    document.getElementById('installBtn').style.display = 'none';
  }
});
// Handle app installed event
window.addEventListener('appinstalled', () => {
  console.log('PWA was installed');
  document.getElementById('installBtn').style.display = 'none';
  showNotification('TC RADIOS installed successfully!');
});
/* ---- WEAR OS SUPPORT ---- */
function initWearOS() {
  // Detect if running on Wear OS
  const isWearOS = window.matchMedia('(max-width: 400px) and (max-height: 400px)').matches;
  if (isWearOS) {
    document.body.classList.add('wear-os');
    // Optimize for smartwatch
    optimizeForWearOS();
    // Add Wear OS specific event listeners
    addWearOSListeners();
  }
}
function optimizeForWearOS() {
  // Reduce animations for battery life
  document.documentElement.style.setProperty('--animation-duration', '0.2s');
  // Optimize touch targets for small screens
  const buttons = document.querySelectorAll('button');
  buttons.forEach(btn => {
    btn.style.minWidth = '32px';
    btn.style.minHeight = '32px';
  });
  // Simplify UI for small screen
  const header = document.querySelector('header');
  if (header) {
    header.style.fontSize = '0.9rem';
    header.style.padding = '0.3rem 0.5rem';
  }
}
function addWearOSListeners() {
  // Add double-tap gesture for play/pause
  let lastTap = 0;
  document.addEventListener('touchend', (e) => {
    const currentTime = new Date().getTime();
    const tapLength = currentTime - lastTap;
    if (tapLength < 500 && tapLength > 0) {
      // Double tap detected
      e.preventDefault();
      audio.paused ? audio.play() : audio.pause();
      hapticFeedback('medium');
    }
    lastTap = currentTime;
  });
  // Add long press for next station
  let longPressTimer;
  document.addEventListener('touchstart', (e) => {
    longPressTimer = setTimeout(() => {
      prevNext(1);
      hapticFeedback('heavy');
    }, 800);
  });
  document.addEventListener('touchend', () => {
    clearTimeout(longPressTimer);
  });
  // Add swipe gestures for station navigation
  let startX, startY;
  document.addEventListener('touchstart', (e) => {
    startX = e.touches[0].clientX;
    startY = e.touches[0].clientY;
  });
  document.addEventListener('touchend', (e) => {
    if (!startX || !startY) return;
    const endX = e.changedTouches[0].clientX;
    const endY = e.changedTouches[0].clientY;
    const diffX = startX - endX;
    const diffY = startY - endY;
    // Horizontal swipe
    if (Math.abs(diffX) > Math.abs(diffY) && Math.abs(diffX) > 30) {
      if (diffX > 0) {
        // Swipe left - next station
        prevNext(1);
        hapticFeedback('light');
      } else {
        // Swipe right - previous station
        prevNext(-1);
        hapticFeedback('light');
      }
    }
    startX = null;
    startY = null;
  });
}
// Enhanced media session for Wear OS
function updateWearOSMediaSession(st) {
  if ('mediaSession' in navigator) {
    // Set Wear OS specific metadata
    navigator.mediaSession.metadata = new MediaMetadata({
      title: st.name,
      artist: 'TC RADIOS',
      album: st.genre || 'Christian Radio',
      artwork: [
        {
          src: st.logo || '/icons/icon-192x192.png',
          sizes: '192x192',
          type: 'image/png'
        },
        {
          src: st.logo || '/icons/icon-512x512.png',
          sizes: '512x512',
          type: 'image/png'
        }
      ]
    });
    // Wear OS specific action handlers
    navigator.mediaSession.setActionHandler('play', () => {
      audio.play();
      hapticFeedback('light');
    });
    navigator.mediaSession.setActionHandler('pause', () => {
      audio.pause();
      hapticFeedback('light');
    });
    navigator.mediaSession.setActionHandler('previoustrack', () => {
      prevNext(-1);
      hapticFeedback('medium');
    });
    navigator.mediaSession.setActionHandler('nexttrack', () => {
      prevNext(1);
      hapticFeedback('medium');
    });
    navigator.mediaSession.setActionHandler('stop', () => {
      audio.pause();
      audio.currentTime = 0;
      hapticFeedback('heavy');
    });
  }
}
/* ---- INITIALIZE MOBILE FEATURES ---- */
window.addEventListener('load', () => {
  // Initialize Android Auto support
  initAndroidAuto();
  // Initialize Wear OS support
  initWearOS();
  // Initialize widget support
  if (window.location.search.includes('widget=true')) {
    // Widget mode - show minimal interface
    document.body.classList.add('widget-mode');
  }
});
/* ---- DYNAMIC PLAYER HEIGHT ---- */
document.documentElement.style.setProperty('--player-height', document.getElementById('player').offsetHeight + 'px');
</script>
</body>
</html>
